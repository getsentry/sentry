# Schema Type Exports

## Export TypeScript types from types.ts, not schemas.ts

When working with schema definitions and their corresponding TypeScript types, follow this separation pattern:

- **schemas.ts**: Contains only the schema definitions (e.g., Zod schemas, JSON schemas, validation schemas) - NO type exports
- **types.ts**: Contains and exports ALL TypeScript type definitions, including those derived from schemas

### ❌ Incorrect - Mixed schemas and types in same file
```typescript
// schemas.ts
import { z } from 'zod';

export const UpdateIssueRequestSchema = z.object({
  status: z.enum(['resolved', 'unresolved', 'ignored']),
  assignedTo: z.string().optional(),
});

// ❌ Don't export types from schemas.ts
export type UpdateIssueRequest = z.infer<typeof UpdateIssueRequestSchema>;
export interface UpdateIssueResponse {
  success: boolean;
  issue: Issue;
}
```

### ✅ Correct - Keep schemas separate from types
```typescript
// schemas.ts - ONLY schema definitions, NO type exports
import { z } from 'zod';

export const UpdateIssueRequestSchema = z.object({
  status: z.enum(['resolved', 'unresolved', 'ignored']),
  assignedTo: z.string().optional(),
});

// types.ts - ALL type definitions
import type { z } from 'zod';
import type { UpdateIssueRequestSchema } from './schemas';

export type UpdateIssueRequest = z.infer<typeof UpdateIssueRequestSchema>;
export interface UpdateIssueResponse {
  success: boolean;
  issue: Issue;
}
```

## Key Principles

1. **schemas.ts files export ONLY schemas** - no `export type` or `export interface`
2. **types.ts files export ALL types** - including schema-derived types
3. **Avoid 'as any' casts** - proper type separation reduces the need for unsafe casting
4. **Import types with `import type`** when importing from schemas for type derivation

## Evaluations (Evals)

Keep evaluations minimal due to their long runtime. Focus only on core use cases rather than comprehensive coverage.
