---
description: React Testing Library syntax and query patterns for *.spec.tsx files
globs: *.spec.tsx
alwaysApply: false
---

# React Testing Library Standards

## Required Imports

**Always** import from `sentry-test/reactTestingLibrary`, not directly from `@testing-library/react`:

```tsx
import {
  render,
  screen,
  userEvent,
  waitFor,
  within,
} from 'sentry-test/reactTestingLibrary';
```

## Query Priority (in order of preference)

1. **`getByRole`** - Primary selector for most elements
   ```tsx
   screen.getByRole('button', { name: 'Save' })
   screen.getByRole('textbox', { name: 'Search' })
   ```

2. **`getByLabelText`/`getByPlaceholderText`** - For form elements
   ```tsx
   screen.getByLabelText('Email Address')
   screen.getByPlaceholderText('Enter Search Term')
   ```

3. **`getByText`** - For non-interactive elements
   ```tsx
   screen.getByText('Error Message')
   ```

4. **`getByTestId`** - Last resort only
   ```tsx
   screen.getByTestId('custom-component')
   ```

## Syntax Standards

### Use `screen` instead of destructuring
```tsx
// ❌ Don't do this
const { getByRole } = render(<Component />);

// ✅ Do this
render(<Component />);
const button = screen.getByRole('button');
```

### Query selection guidelines
- Use `getBy...` for elements that should exist
- Use `queryBy...` ONLY when checking for non-existence
- Use `await findBy...` when waiting for elements to appear

```tsx
// ❌ Wrong
expect(screen.queryByRole('alert')).toBeInTheDocument();

// ✅ Correct
expect(screen.getByRole('alert')).toBeInTheDocument();
expect(screen.queryByRole('button')).not.toBeInTheDocument();
```

### Async testing patterns
```tsx
// ❌ Don't use waitFor for appearance
await waitFor(() => {
  expect(screen.getByRole('alert')).toBeInTheDocument();
});

// ✅ Use findBy for appearance
expect(await screen.findByRole('alert')).toBeInTheDocument();

// ✅ Use waitForElementToBeRemoved for disappearance
await waitForElementToBeRemoved(() => screen.getByRole('alert'));
```

### User interaction syntax
```tsx
// ❌ Don't use fireEvent
fireEvent.change(input, { target: { value: 'text' } });

// ✅ Use userEvent
await userEvent.click(input);
await userEvent.keyboard('text');
```

### Router testing syntax
```tsx
const { router } = render(<TestComponent />, {
  initialRouterConfig: {
    location: {
      pathname: "/foo/",
      query: { page: "1" },
    },
  },
});

// Check current route
expect(router.location.pathname).toBe("/foo");
expect(router.location.query.page).toBe("1");

// Test navigation
await userEvent.click(screen.getByRole("link", { name: "Go to /bar/" }));
expect(router.location.pathname).toBe("/bar/");

// Manual navigation
router.navigate("/new/path/");
router.navigate(-1); // Back button
```

### Mock API request syntax
```tsx
// Simple GET request
MockApiClient.addMockResponse({
  url: "/projects/",
  body: [{ id: 1, name: "my project" }],
});

// POST with matching
MockApiClient.addMockResponse({
  url: "/projects/",
  method: "POST",
  body: { id: 2, name: "other" },
  match: [
    MockApiClient.matchQuery({ param: "1" }),
    MockApiClient.matchData({ name: "other" }),
  ],
});

// Error responses
MockApiClient.addMockResponse({
  url: "/projects/",
  body: { detail: "Internal Error" },
  statusCode: 500,
});
```
