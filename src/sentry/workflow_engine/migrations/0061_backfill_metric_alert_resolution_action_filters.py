# Generated by Django 5.1.7 on 2025-05-08 21:27
from enum import Enum

from django.apps.registry import Apps
from django.db import migrations, router, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor

from sentry.new_migrations.migrations import CheckedMigration
from sentry.utils.query import RangeQuerySetWrapper


class AlertRuleStatus(Enum):
    PENDING = 0
    SNAPSHOT = 4
    DISABLED = 5
    NOT_ENOUGH_DATA = 6


def backfill_resolution_action_filters(apps: Apps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    AlertRule = apps.get_model("sentry", "AlertRule")
    Organization = apps.get_model("sentry", "Organization")

    AlertRuleWorkflow = apps.get_model("workflow_engine", "AlertRuleWorkflow")
    DataCondition = apps.get_model("workflow_engine", "DataCondition")
    DataConditionGroup = apps.get_model("workflow_engine", "DataConditionGroup")

    for organization in RangeQuerySetWrapper(Organization.objects.all()):
        organization_id = organization.id
        alert_rule_ids = AlertRule.objects_with_snapshots.filter(
            organization_id=organization_id, status=AlertRuleStatus.PENDING.value
        ).values_list("id", flat=True)

        workflow_ids = AlertRuleWorkflow.objects.filter(
            alert_rule_id__in=alert_rule_ids
        ).values_list("workflow__id", flat=True)

        for workflow_id in workflow_ids:
            workflow_dcgs = DataConditionGroup.objects.filter(
                workflowdataconditiongroup__workflow__id=workflow_id
            )

            with transaction.atomic(router.db_for_write(DataCondition)):
                for dcg in workflow_dcgs:
                    if DataCondition.objects.filter(
                        condition_group=dcg, type="issue_priority_deescalating"
                    ).exists():
                        # the resolution action filter has already been created, either via dual write or a previous migration
                        # I have this inside the loop because it's possible someone added a new condition after we turned
                        # on dual write of resolution action filters, so one of the conditions is correct and the other
                        # needs to be backfilled
                        continue

                    action_filter = DataCondition.objects.get(
                        condition_group=dcg,
                    )
                    comparison = action_filter.comparison
                    DataCondition.objects.create(
                        comparison=comparison,
                        condition_result=True,
                        type="issue_priority_deescalating",
                        condition_group=dcg,
                    )


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production.
    # This should only be used for operations where it's safe to run the migration after your
    # code has deployed. So this should not be used for most operations that alter the schema
    # of a table.
    # Here are some things that make sense to mark as post deployment:
    # - Large data migrations. Typically we want these to be run manually so that they can be
    #   monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   run this outside deployments so that we don't block them. Note that while adding an index
    #   is a schema change, it's completely safe to run the operation after the code has deployed.
    # Once deployed, run these manually via: https://develop.sentry.dev/database-migrations/#migration-deployment

    is_post_deployment = True

    dependencies = [
        ("workflow_engine", "0060_rename_azure_devops_action_to_vsts"),
    ]

    operations = [
        migrations.RunPython(
            backfill_resolution_action_filters,
            migrations.RunPython.noop,
            hints={"tables": ["workflow_engine_alertruleworkflow"]},
        ),
    ]
