# Generated by Django 5.2.1 on 2025-10-29 20:40

from typing import Any

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Prefetch

from sentry.new_migrations.migrations import CheckedMigration
from sentry.utils import json
from sentry.utils.query import RangeQuerySetWrapper


class WorkflowData:
    workflow: Any  # the workflow with related models

    def __init__(self, workflow: Any) -> None:
        self.workflow = workflow

    def serialize(self) -> str:
        workflow_data: dict[str, Any] = {}
        return json.dumps(workflow_data)


def deduplicate_workflows(app: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    Organization = app.get_model("sentry", "Organization")
    AlertRuleWorkflow = app.get_model("sentry", "AlertRuleWorkflow")
    Workflow = app.get_model("workflow_engine", "Workflow")
    DetectorWorkflow = app.get_model("workflow_engine", "DetectorWorkflow")
    DataCondition = app.get_model("workflow_engine", "DataCondition")
    WorkflowDataConditionGroup = app.get_model("workflow_engine", "WorkflowDataConditionGroup")
    DataConditionGroupAction = app.get_model("workflow_engine", "DataConditionGroupAction")
    Workflow = app.get_model("workflow_engine", "Workflow")

    organizations = Organization.objects.filter()

    # iterate through each org, and get the workflow in a batch
    # make sure to select the workflows related models.
    for org in RangeQuerySetWrapper(organizations):
        workflows = (
            Workflow.objects.filter(organization=org)
            .select_related("when_condition_group")
            .prefetch_related(
                Prefetch(
                    "when_condition_group__conditions",
                    queryset=DataCondition.objects.all(),
                    to_attr="prefetched_when_conditions",
                ),
                Prefetch(
                    "workflowdataconditiongroup_set",
                    queryset=WorkflowDataConditionGroup.objects.select_related(
                        "condition_group"
                    ).prefetch_related(
                        Prefetch(
                            "condition_group__conditions",
                            queryset=DataCondition.objects.all(),
                            to_attr="prefetched_conditions",
                        ),
                        Prefetch(
                            "condition_group__dataconditiongroupaction_set",
                            queryset=DataConditionGroupAction.objects.select_related("action"),
                            to_attr="prefetched_actions",
                        ),
                    ),
                    to_attr="prefetched_action_groups",
                ),
                # TODO -- :thinking: should i also update this relationship or is it no longer needed?
                Prefetch(
                    "alertruleworkflow_set",
                    queryset=AlertRuleWorkflow.objects.all(),
                    to_attr="prefetched_rule_workflows",
                ),
            )
            .distinct()
        )

        workflow_data_to_ids: dict[str, list[int]] = {}
        # TODO - should this use a RangeQuerySet? :thinking:
        for workflow in workflows:
            workflow_data = WorkflowData(workflow)
            workflow_hash = workflow_data.serialize()

            if workflow_data_to_ids[workflow_hash]:
                workflow_data_to_ids[workflow_hash].append(workflow.id)
            else:
                workflow_data_to_ids[workflow_hash] = [workflow.id]

        for workflow_hash, workflow_ids in workflow_data_to_ids.items():
            if len(workflow_ids) <= 1:
                continue

            # Get the first workflow and remove it from the list of duplicate ids
            workflow_id = workflow_ids.pop(0)
            DetectorWorkflow.objects.filter(workflow_ids__in=workflow_ids).update(
                workflow_id=workflow_id
            )
            # Update the DetectorWorkflow by selecting a


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production.
    # This should only be used for operations where it's safe to run the migration after your
    # code has deployed. So this should not be used for most operations that alter the schema
    # of a table.
    # Here are some things that make sense to mark as post deployment:
    # - Large data migrations. Typically we want these to be run manually so that they can be
    #   monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   run this outside deployments so that we don't block them. Note that while adding an index
    #   is a schema change, it's completely safe to run the operation after the code has deployed.
    # Once deployed, run these manually via: https://develop.sentry.dev/database-migrations/#migration-deployment

    is_post_deployment = True

    dependencies = [
        ("workflow_engine", "0093_add_action_config_index"),
    ]

    operations = [
        migrations.RunPython(
            deduplicate_workflows,
            migrations.RunPython.noop,
            hints={"tables": ["workflow_engineworkflow", "workflow_enginedetectorworkflow"]},
        )
    ]
