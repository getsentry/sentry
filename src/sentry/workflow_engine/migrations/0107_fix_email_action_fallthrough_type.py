# Generated by Django 5.2.8 on 2026-01-22 18:25

import logging
from typing import Any

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps

from sentry.new_migrations.migrations import CheckedMigration
from sentry.utils.query import RangeQuerySetWrapper

logger = logging.getLogger(__name__)

EMAIL_ACTION_REGISTRY_ID = "sentry.mail.actions.NotifyEmailAction"

# Target type mappings (from ActionTarget enum)
TARGET_TYPE_USER = 1
TARGET_TYPE_TEAM = 2
TARGET_TYPE_ISSUE_OWNERS = 4

# Maps Rule action targetType string to Action config target_type int
TARGET_TYPE_STRING_TO_INT = {
    "Member": TARGET_TYPE_USER,
    "Team": TARGET_TYPE_TEAM,
    "IssueOwners": TARGET_TYPE_ISSUE_OWNERS,
}

DEFAULT_FALLTHROUGH_TYPE = "ActiveMembers"


def translate_email_action(rule_action: dict[str, Any]) -> dict[str, Any]:
    """
    Translate a Rule email action blob to Action model fields.
    Returns dict with: data, config, integration_id
    """
    target_type_str = rule_action.get("targetType")
    if not target_type_str:
        raise ValueError("targetType is required for email actions")

    target_type_int = TARGET_TYPE_STRING_TO_INT.get(target_type_str)
    if target_type_int is None:
        raise ValueError(f"Unknown targetType: {target_type_str}")

    # Build config
    config: dict[str, Any] = {
        "target_type": target_type_int,
        "target_display": None,
    }

    # target_identifier is only set for Member/Team, not IssueOwners
    if target_type_str in ("Member", "Team"):
        target_identifier = rule_action.get("targetIdentifier")
        config["target_identifier"] = str(target_identifier) if target_identifier else str(None)
    else:
        config["target_identifier"] = None

    # Build data - only IssueOwners has fallthrough_type
    data: dict[str, Any] = {}
    if target_type_str == "IssueOwners":
        # Check both possible keys for fallthrough type
        fallthrough_type = rule_action.get("fallthrough_type")
        if fallthrough_type is None:
            fallthrough_type = rule_action.get("fallthroughType", DEFAULT_FALLTHROUGH_TYPE)
        data["fallthrough_type"] = str(fallthrough_type)

    return {
        "data": data,
        "config": config,
        "integration_id": None,  # Email actions don't use integrations
    }


def fix_email_action_fallthrough_type(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    """
    Fix email actions that were incorrectly migrated with missing fallthrough_type.

    This migration:
    1. Finds all Workflows that have at least 1 Action of type="email"
    2. For each workflow, fetches the Rule through AlertRuleWorkflow
    3. Gets the NotifyEmailAction actions from Rule.data["actions"]
    4. Gets the email actions for the workflow
    5. Overwrites each Action with translated data from the rule action
    """
    Rule = apps.get_model("sentry", "Rule")
    Workflow = apps.get_model("workflow_engine", "Workflow")
    Action = apps.get_model("workflow_engine", "Action")
    AlertRuleWorkflow = apps.get_model("workflow_engine", "AlertRuleWorkflow")

    # Iterate directly through workflows with email actions
    workflows_with_email_actions = Workflow.objects.filter(
        workflowdataconditiongroup__condition_group__dataconditiongroupaction__action__type="email"
    ).distinct()

    for workflow in RangeQuerySetWrapper(workflows_with_email_actions):
        try:
            # Get the Rule for this workflow through AlertRuleWorkflow
            alert_rule_workflow = AlertRuleWorkflow.objects.filter(workflow_id=workflow.id).first()
            if not alert_rule_workflow or not alert_rule_workflow.rule_id:
                logger.info(
                    "workflow.no_rule_link",
                    extra={"workflow_id": workflow.id},
                )
                continue

            try:
                rule = Rule.objects.get(id=alert_rule_workflow.rule_id)
            except Rule.DoesNotExist:
                logger.info(
                    "workflow.rule_not_found",
                    extra={
                        "workflow_id": workflow.id,
                        "rule_id": alert_rule_workflow.rule_id,
                    },
                )
                continue

            # Rule email actions
            rule_actions = rule.data.get("actions", [])
            rule_email_actions = [
                action for action in rule_actions if action.get("id") == EMAIL_ACTION_REGISTRY_ID
            ]

            if not rule_email_actions:
                logger.info(
                    "workflow.no_rule_email_actions",
                    extra={"workflow_id": workflow.id, "rule_id": rule.id},
                )
                continue

            # Workflow email actions
            workflow_email_actions = list(
                Action.objects.filter(
                    dataconditiongroupaction__condition_group__workflowdataconditiongroup__workflow_id=workflow.id,
                    type="email",
                )
                .distinct()
                .order_by("id")
            )

            if not workflow_email_actions:
                logger.info(
                    "workflow.no_workflow_email_actions",
                    extra={"workflow_id": workflow.id},
                )
                continue

            # Translate rule email actions
            translated_actions = []
            for rule_action in rule_email_actions:
                try:
                    translated_actions.append(translate_email_action(rule_action))
                except ValueError:
                    logger.exception(
                        "workflow.translate_action_error",
                        extra={
                            "workflow_id": workflow.id,
                            "rule_id": rule.id,
                            "rule_action": rule_action,
                        },
                    )
                    continue

            if len(translated_actions) != len(workflow_email_actions):
                logger.warning(
                    "workflow.action_count_mismatch",
                    extra={
                        "workflow_id": workflow.id,
                        "rule_id": rule.id,
                        "translated_count": len(translated_actions),
                        "workflow_count": len(workflow_email_actions),
                    },
                )
                continue

            # Overwrite each workflow action with the translated data
            for i, workflow_action in enumerate(workflow_email_actions):
                if i >= len(translated_actions):
                    break

                translated = translated_actions[i]

                workflow_action.data = translated["data"]
                workflow_action.config = translated["config"]
                workflow_action.integration_id = translated["integration_id"]
                workflow_action.save()

            logger.info(
                "workflow.actions_updated",
                extra={
                    "workflow_id": workflow.id,
                    "action_ids": [action.id for action in workflow_email_actions],
                },
            )

        except Exception:
            logger.exception(
                "workflow.migration_error",
                extra={"workflow_id": workflow.id},
            )
            continue


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production.
    # This should only be used for operations where it's safe to run the migration after your
    # code has deployed. So this should not be used for most operations that alter the schema
    # of a table.
    # Here are some things that make sense to mark as post deployment:
    # - Large data migrations. Typically we want these to be run manually so that they can be
    #   monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   run this outside deployments so that we don't block them. Note that while adding an index
    #   is a schema change, it's completely safe to run the operation after the code has deployed.
    # Once deployed, run these manually via: https://develop.sentry.dev/database-migrations/#migration-deployment

    is_post_deployment = True

    dependencies = [
        ("workflow_engine", "0106_migrate_actions_sentry_app_data"),
    ]

    operations = [
        migrations.RunPython(
            fix_email_action_fallthrough_type,
            migrations.RunPython.noop,
            hints={"tables": ["workflow_engine_action", "workflow_engine_workflow", "sentry_rule"]},
        )
    ]
