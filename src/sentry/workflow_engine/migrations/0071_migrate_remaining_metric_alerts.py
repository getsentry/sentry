# Generated by Django 5.2.1 on 2025-06-03 21:44

import dataclasses
import logging
from enum import Enum, IntEnum, StrEnum
from typing import Any

import sentry_sdk
from attr import dataclass
from django.apps.registry import Apps
from django.db import migrations, router, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.models import Exists, OuterRef
from jsonschema import ValidationError, validate

from sentry.new_migrations.migrations import CheckedMigration
from sentry.utils.query import RangeQuerySetWrapper

logger = logging.getLogger(__name__)


class PriorityLevel(IntEnum):
    LOW = 25
    MEDIUM = 50
    HIGH = 75


class DetectorPriorityLevel(IntEnum):
    OK = 0
    LOW = PriorityLevel.LOW
    MEDIUM = PriorityLevel.MEDIUM
    HIGH = PriorityLevel.HIGH


class IncidentStatus(Enum):
    OPEN = 1
    CLOSED = 2
    WARNING = 10
    CRITICAL = 20


class IncidentType(Enum):
    DETECTED = 0
    ALERT_TRIGGERED = 2


class AlertRuleStatus(Enum):
    PENDING = 0
    SNAPSHOT = 4
    DISABLED = 5
    NOT_ENOUGH_DATA = 6


class AlertRuleThresholdType(Enum):
    ABOVE = 0
    BELOW = 1
    ABOVE_AND_BELOW = 2


class Condition(StrEnum):
    EQUAL = "eq"
    GREATER_OR_EQUAL = "gte"
    GREATER = "gt"
    LESS_OR_EQUAL = "lte"
    LESS = "lt"
    ISSUE_PRIORITY_GREATER_OR_EQUAL = "issue_priority_greater_or_equal"
    ISSUE_PRIORITY_DEESCALATING = "issue_priority_deescalating"
    ANOMALY_DETECTION = "anomaly_detection"


class AlertRuleActivityType(Enum):
    CREATED = 1
    DELETED = 2
    UPDATED = 3
    ENABLED = 4
    DISABLED = 5
    SNAPSHOT = 6
    ACTIVATED = 7
    DEACTIVATED = 8


class AlertRuleTriggerActionType(Enum):
    EMAIL = 0
    PAGERDUTY = 1
    SLACK = 2
    MSTEAMS = 3
    SENTRY_APP = 4
    SENTRY_NOTIFICATION = 5  # Use personal notification platform (src/sentry/notifications)
    OPSGENIE = 6
    DISCORD = 7


MAX_ACTIONS = 3

ACTION_TYPE_TO_STRING = {
    AlertRuleTriggerActionType.PAGERDUTY.value: "PagerDuty",
    AlertRuleTriggerActionType.SLACK.value: "Slack",
    AlertRuleTriggerActionType.MSTEAMS.value: "Microsoft Teams",
    AlertRuleTriggerActionType.OPSGENIE.value: "Opsgenie",
    AlertRuleTriggerActionType.DISCORD.value: "Discord",
}


class ActionTarget(IntEnum):
    """
    Explains the contents of target_identifier
    """

    # The target_identifier is a direct reference used by the service (e.g. email address, slack channel id)
    SPECIFIC = 0
    # The target_identifier is an id from the User model in Sentry
    USER = 1
    # The target_identifier is an id from the Team model in Sentry
    TEAM = 2
    # The target_identifier is an id from the SentryApp model in Sentry
    SENTRY_APP = 3
    # There is no target_identifier, but we want to send notifications to the issue owners
    ISSUE_OWNERS = 4


class ActionType(StrEnum):
    SLACK = "slack"
    MSTEAMS = "msteams"
    DISCORD = "discord"

    PAGERDUTY = "pagerduty"
    OPSGENIE = "opsgenie"

    EMAIL = "email"
    SENTRY_APP = "sentry_app"


class SentryAppIdentifier(StrEnum):
    """
    SentryAppIdentifier is an enum that represents the identifier for a Sentry app.
    """

    SENTRY_APP_INSTALLATION_UUID = "sentry_app_installation_uuid"
    SENTRY_APP_SLUG = "sentry_app_slug"
    SENTRY_APP_ID = "sentry_app_id"


FIELDS_TO_DETECTOR_FIELDS = {
    "name": "name",
    "description": "description",
    "user_id": "owner_user_id",
    "team_id": "owner_team_id",
}

TYPE_TO_PROVIDER = {
    0: "email",
    1: "pagerduty",
    2: "slack",
    3: "msteams",
    4: "sentry_app",
    6: "opsgenie",
    7: "discord",
}

PRIORITY_MAP = {
    "warning": DetectorPriorityLevel.MEDIUM,
    "critical": DetectorPriorityLevel.HIGH,
}


OPSGENIE_DEFAULT_PRIORITY = "P3"
PAGERDUTY_DEFAULT_SEVERITY = "default"


class PagerdutySeverity(StrEnum):
    DEFAULT = "default"
    CRITICAL = "critical"
    WARNING = "warning"
    ERROR = "error"
    INFO = "info"


@dataclass
class ActionSchemas:
    config_schema: dict[str, Any] | None = None
    data_schema: dict[str, Any] | None = None


@dataclasses.dataclass
class SentryAppFormConfigDataBlob:
    """
    SentryAppFormConfigDataBlob represents a single form config field for a Sentry App.
    name is the name of the form field, and value is the value of the form field.
    """

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "SentryAppFormConfigDataBlob":
        if not isinstance(data.get("name"), str) or not isinstance(
            data.get("value"), (str, type(None))
        ):
            raise ValueError("Sentry app config must contain name and value keys")
        return cls(name=data["name"], value=data["value"], label=data.get("label"))

    name: str = ""
    value: str = ""
    label: str | None = None


@dataclasses.dataclass
class SentryAppDataBlob:
    """
    Represents a Sentry App notification action.
    """

    settings: list[SentryAppFormConfigDataBlob] = dataclasses.field(default_factory=list)

    @classmethod
    def from_list(cls, data: list[dict[str, Any]] | None) -> "SentryAppDataBlob":
        if data is None:
            return cls()
        return cls(settings=[SentryAppFormConfigDataBlob.from_dict(setting) for setting in data])


@dataclasses.dataclass
class OnCallDataBlob:
    """
    OnCallDataBlob is a specific type that represents the data blob for a PagerDuty or Opsgenie notification action.
    """

    priority: str = ""


action_schema_mapping: dict[str, ActionSchemas] = {
    ActionType.EMAIL: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for an email Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": ["string", "null"]},
                "target_display": {"type": ["null"]},
                "target_type": {
                    "type": ["integer"],
                    "enum": [*ActionTarget],
                },
            },
            "required": ["target_type"],
            "additionalProperties": False,
        },
        data_schema={},
    ),
    ActionType.PAGERDUTY: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for a on-call Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": ["string"]},
                "target_display": {"type": ["string", "null"]},
                "target_type": {"type": ["integer"], "enum": [0]},
            },
            "required": ["target_identifier", "target_type"],
            "additionalProperties": False,
        },
        data_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "type": "object",
            "properties": {
                "priority": {
                    "type": "string",
                    "description": "The priority of the pagerduty action",
                    "enum": [*PagerdutySeverity],
                },
                "additionalProperties": False,
            },
        },
    ),
    ActionType.SLACK: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for a Messaging Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": ["string"]},
                "target_display": {"type": ["string"]},
                "target_type": {
                    "type": ["integer"],
                    "enum": [ActionTarget.SPECIFIC.value],
                },
            },
            "required": ["target_identifier", "target_display", "target_type"],
            "additionalProperties": False,
        },
        data_schema={},
    ),
    ActionType.MSTEAMS: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for a Messaging Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": ["string"]},
                "target_display": {"type": ["string"]},
                "target_type": {
                    "type": ["integer"],
                    "enum": [ActionTarget.SPECIFIC.value],
                },
            },
            "required": ["target_identifier", "target_display", "target_type"],
            "additionalProperties": False,
        },
        data_schema={},
    ),
    ActionType.SENTRY_APP: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for a Sentry App Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": ["string"]},
                "target_display": {"type": ["string", "null"]},
                "target_type": {"type": ["integer"], "enum": [3]},
                "sentry_app_identifier": {"type": ["string"], "enum": [*SentryAppIdentifier]},
            },
            "required": ["target_type", "target_identifier", "sentry_app_identifier"],
            "additionalProperties": False,
        },
        data_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "type": "object",
            "properties": {"settings": {"type": ["array", "object"]}},
            "additionalProperties": False,
        },
    ),
    ActionType.OPSGENIE: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for a on-call Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": ["string"]},
                "target_display": {"type": ["string", "null"]},
                "target_type": {
                    "type": ["integer"],
                    "enum": [ActionTarget.SPECIFIC.value],
                },
            },
            "required": ["target_identifier", "target_type"],
            "additionalProperties": False,
        },
        data_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "type": "object",
            "properties": {
                "priority": {
                    "type": "string",
                    "description": "The priority of the opsgenie action",
                    "enum": ["P1", "P2", "P3", "P4", "P5"],
                },
                "additionalProperties": False,
            },
        },
    ),
    ActionType.DISCORD: ActionSchemas(
        config_schema={
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "description": "The configuration schema for a Discord Action",
            "type": "object",
            "properties": {
                "target_identifier": {"type": "string"},
                "target_display": {
                    "type": ["string", "null"],
                },
                "target_type": {
                    "type": ["integer"],
                    "enum": [ActionTarget.SPECIFIC.value],
                },
            },
            "required": ["target_identifier", "target_type"],
            "additionalProperties": False,
        },
        data_schema={},
    ),
}


def _enforce_action_json_schema(action: Any) -> None:
    schemas = action_schema_mapping.get(action.type)
    if not schemas:
        logger.error(
            "No schema found for action type",
            extra={"action_type": action.type},
        )
        return
    config_schema = schemas.config_schema
    data_schema = schemas.data_schema

    if config_schema is not None:
        try:
            validate(action.config, config_schema)
        except ValidationError as e:
            raise ValidationError(f"Invalid config: {e.message}")

    if data_schema is not None:
        try:
            validate(action.data, data_schema)
        except ValidationError as e:
            raise ValidationError(f"Invalid data: {e.message}")


def _get_trigger_action_target(apps: Apps, trigger_action: Any) -> Any:
    OrganizationMember = apps.get_model("sentry", "OrganizationMember")
    Team = apps.get_model("sentry", "Team")

    if trigger_action.target_identifier is None:
        return None

    if trigger_action.target_type == ActionTarget.USER.value:
        try:
            return OrganizationMember.objects.get(
                user_id=int(trigger_action.target_identifier),
                organization=trigger_action.alert_rule_trigger.alert_rule.organization_id,
            )
        except OrganizationMember.DoesNotExist:
            pass

    elif trigger_action.target_type == ActionTarget.TEAM.value:
        try:
            return Team.objects.get(id=int(trigger_action.target_identifier))
        except Team.DoesNotExist:
            pass

    elif trigger_action.target_type == ActionTarget.SPECIFIC.value:
        return trigger_action.target_identifier
    return None


def _get_action_description(apps: Apps, action: Any) -> str:
    """
    Returns a human readable action description
    """
    if action.type == AlertRuleTriggerActionType.EMAIL.value:
        target = _get_trigger_action_target(apps, action)
        if target:
            if action.target_type == ActionTarget.USER.value:
                action_target_user = target
                return "Email " + action_target_user.user_email
            elif action.target_type == ActionTarget.TEAM.value:
                action_target_team = target
                return "Email #" + action_target_team.slug
        else:
            return "Email [removed]"
    elif action.type == AlertRuleTriggerActionType.SENTRY_APP.value:
        return f"Notify {action.target_display}"

    return f"Notify {action.target_display} via {ACTION_TYPE_TO_STRING[action.type]}"


def _get_workflow_name(apps: Apps, alert_rule: Any) -> str:
    """
    Generate a workflow name like 'Slack @michelle.fu, Email michelle.fu@sentry.io...(+3)' if there is only a critical trigger
    or with priority label: 'Critical - Slack @michelle.fu, Warning email michelle.fu@sentry.io...(+3)''
    """
    AlertRuleTrigger = apps.get_model("sentry", "AlertRuleTrigger")
    AlertRuleTriggerAction = apps.get_model("sentry", "AlertRuleTriggerAction")

    name = ""
    triggers = AlertRuleTrigger.objects.filter(alert_rule_id=alert_rule.id).order_by("label")
    include_label = False if triggers.count() == 1 else True

    actions = AlertRuleTriggerAction.objects.filter(
        alert_rule_trigger_id__in=[trigger.id for trigger in triggers], status=0
    )
    actions_counter = 0

    for trigger in triggers:
        name += f"{trigger.label.title()} - " if include_label else ""
        for action in actions.filter(alert_rule_trigger_id=trigger.id):
            description = _get_action_description(apps, action) + ", "

            if actions_counter < MAX_ACTIONS:
                name += description
                actions_counter += 1
            else:
                remaining_actions = actions.count() - actions_counter
                name = name[:-2]
                name += f"...(+{remaining_actions})"
                break

    if name[-2:] == ", ":
        name = name[:-2]  # chop off the trailing comma

    return name


def _migrate_trigger(apps: Apps, trigger: Any, detector: Any, workflow: Any) -> None:
    AlertRuleTriggerAction = apps.get_model("sentry", "AlertRuleTriggerAction")
    DataCondition = apps.get_model("workflow_engine", "DataCondition")
    DataConditionGroup = apps.get_model("workflow_engine", "DataConditionGroup")
    WorkflowDataConditionGroup = apps.get_model("workflow_engine", "WorkflowDataConditionGroup")
    DataConditionAlertRuleTrigger = apps.get_model(
        "workflow_engine", "DataConditionAlertRuleTrigger"
    )

    alert_rule = trigger.alert_rule
    condition_result = PRIORITY_MAP.get(trigger.label, DetectorPriorityLevel.HIGH)
    threshold_type = (
        Condition.GREATER
        if alert_rule.threshold_type == AlertRuleThresholdType.ABOVE.value
        else Condition.LESS
    )
    # create detector trigger
    if alert_rule.detection_type == "dynamic":
        detector_trigger = DataCondition.objects.create(
            type=Condition.ANOMALY_DETECTION,
            comparison={
                "sensitivity": alert_rule.sensitivity,
                "seasonality": alert_rule.seasonality,
                "threshold_type": alert_rule.threshold_type,
            },
            condition_result=condition_result,
            condition_group=detector.workflow_condition_group,
        )
    else:
        detector_trigger = DataCondition.objects.create(
            comparison=trigger.alert_threshold,
            condition_result=condition_result,
            type=threshold_type,
            condition_group=detector.workflow_condition_group,
        )
    DataConditionAlertRuleTrigger.objects.create(
        data_condition=detector_trigger,
        alert_rule_trigger_id=trigger.id,
    )
    # create action filter
    data_condition_group = DataConditionGroup.objects.create(
        organization_id=alert_rule.organization_id
    )
    WorkflowDataConditionGroup.objects.create(
        condition_group=data_condition_group,
        workflow=workflow,
    )
    action_filter = DataCondition.objects.create(
        comparison=PRIORITY_MAP.get(trigger.label, DetectorPriorityLevel.HIGH),
        condition_result=True,
        type=Condition.ISSUE_PRIORITY_GREATER_OR_EQUAL,
        condition_group=data_condition_group,
    )

    # resolve action filter
    DataCondition.objects.create(
        comparison=PRIORITY_MAP.get(trigger.label, DetectorPriorityLevel.HIGH),
        condition_result=True,
        type=Condition.ISSUE_PRIORITY_DEESCALATING,
        condition_group=data_condition_group,
    )

    trigger_actions = AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger)
    for trigger_action in trigger_actions:
        # 0 is active status
        if trigger_action.status != 0:
            continue
        _migrate_trigger_action(apps, trigger_action, action_filter.condition_group.id)


def _migrate_trigger_action(apps: Apps, trigger_action: Any, condition_group_id: int) -> None:
    DataConditionGroupAction = apps.get_model("workflow_engine", "DataConditionGroupAction")
    Action = apps.get_model("workflow_engine", "Action")
    ActionAlertRuleTriggerAction = apps.get_model("workflow_engine", "ActionAlertRuleTriggerAction")
    if trigger_action.sentry_app_id:
        action_type = ActionType.SENTRY_APP

    elif trigger_action.integration_id:
        try:
            action_type = ActionType(TYPE_TO_PROVIDER[trigger_action.type])
        except Exception:
            logger.info(
                "could not find a matching action type for the trigger action",
                extra={"trigger_action_id": trigger_action.id},
            )
            raise
    else:
        action_type = ActionType.EMAIL

    # build data blob
    if action_type == ActionType.SENTRY_APP:
        if not trigger_action.sentry_app_config:
            data = {}
        else:
            settings = (
                [trigger_action.sentry_app_config]
                if isinstance(trigger_action.sentry_app_config, dict)
                else trigger_action.sentry_app_config
            )
            data = dataclasses.asdict(SentryAppDataBlob.from_list(settings))
    elif action_type in (ActionType.OPSGENIE, ActionType.PAGERDUTY):
        default_priority = (
            OPSGENIE_DEFAULT_PRIORITY
            if action_type == ActionType.OPSGENIE
            else PAGERDUTY_DEFAULT_SEVERITY
        )

        if not trigger_action.sentry_app_config:
            data = {"priority": default_priority}
        else:
            # Ensure sentry_app_config is a dict before accessing
            config = trigger_action.sentry_app_config
            if not isinstance(config, dict):
                data = {"priority": default_priority}
            else:
                priority = config.get("priority", default_priority)
                data = dataclasses.asdict(OnCallDataBlob(priority=priority))
    else:
        data = {}

    # get target identifier
    if action_type == ActionType.SENTRY_APP:
        if not trigger_action.sentry_app_id:
            logger.info(
                "trigger action missing sentry app ID",
                extra={"trigger_action_id": trigger_action.id},
            )
            raise Exception("Trigger action missing Sentry app ID")
        target_identifier = str(trigger_action.sentry_app_id)
    else:
        target_identifier = trigger_action.target_identifier

    # build config
    target_type = trigger_action.target_type
    config = {
        "target_display": trigger_action.target_display,
        "target_identifier": target_identifier,
        "target_type": target_type,
    }
    if target_type == ActionTarget.SENTRY_APP.value:
        config["sentry_app_identifier"] = SentryAppIdentifier.SENTRY_APP_ID

    # create the models
    action = Action.objects.create(
        type=action_type,
        data=data,
        integration_id=trigger_action.integration_id,
        config=config,
    )

    _enforce_action_json_schema(action)

    DataConditionGroupAction.objects.create(
        condition_group_id=condition_group_id,
        action_id=action.id,
    )
    ActionAlertRuleTriggerAction.objects.create(
        action_id=action.id,
        alert_rule_trigger_action_id=trigger_action.id,
    )


def _create_data_source(apps: Apps, alert_rule: Any) -> Any:
    DataSource = apps.get_model("workflow_engine", "DataSource")
    QuerySubscription = apps.get_model("sentry", "QuerySubscription")

    snuba_query = alert_rule.snuba_query
    if not snuba_query:
        logger.info("alert rule missing snuba query", extra={"alert_rule_id": alert_rule.id})
        raise Exception("Alert rule missing snuba query")
    try:
        query_subscription = QuerySubscription.objects.get(snuba_query=snuba_query.id)
    except QuerySubscription.DoesNotExist:
        logger.info(
            "query subscription does not exist",
            extra={"snuba_query_id": snuba_query.id},
        )
        raise Exception("Query subscription does not exist")
    data_source = DataSource.objects.create(
        organization_id=alert_rule.organization_id,
        source_id=str(query_subscription.id),
        type="snuba_query_subscription",
    )
    return data_source


def _create_detector(
    apps: Apps,
    alert_rule: Any,
    project: Any,
    data_condition_group: Any,
    create_activity: Any,
    enabled: bool,
) -> Any:
    Detector = apps.get_model("workflow_engine", "Detector")
    detector = Detector.objects.create(
        project_id=project.id,
        enabled=enabled,
        created_by_id=create_activity.user_id if create_activity else None,
        name=alert_rule.name if len(alert_rule.name) < 200 else alert_rule.name[:197] + "...",
        workflow_condition_group=data_condition_group,
        type="metric_issue",
        description=alert_rule.description,
        owner_user_id=alert_rule.user_id,
        owner_team=alert_rule.team,
        config={
            "threshold_period": alert_rule.threshold_period,
            "sensitivity": alert_rule.sensitivity,
            "seasonality": alert_rule.seasonality,
            "comparison_delta": alert_rule.comparison_delta,
            "detection_type": alert_rule.detection_type,
        },
    )
    Detector.objects.filter(id=detector.id).update(date_added=alert_rule.date_added)
    return detector


def _create_detector_state(apps: Apps, alert_rule: Any, project: Any, detector: Any) -> None:
    Incident = apps.get_model("sentry", "Incident")
    DetectorState = apps.get_model("workflow_engine", "DetectorState")

    incident_query = Incident.objects.filter(
        type=IncidentType.ALERT_TRIGGERED.value,
        alert_rule=alert_rule,
        projects=project,
    )
    open_incident = (
        incident_query.exclude(status=IncidentStatus.CLOSED.value).order_by("-date_added").first()
    )
    if open_incident:
        state = (
            DetectorPriorityLevel.MEDIUM
            if open_incident.status == IncidentStatus.WARNING.value
            else DetectorPriorityLevel.HIGH
        )
    else:
        state = DetectorPriorityLevel.OK
    # create detector state
    DetectorState.objects.create(
        detector=detector,
        is_triggered=True if open_incident else False,
        state=state,
    )


def _migrate_resolve_threshold(apps: Apps, alert_rule: Any, detector: Any) -> None:
    DataCondition = apps.get_model("workflow_engine", "DataCondition")

    resolve_threshold_type = (
        Condition.LESS_OR_EQUAL
        if alert_rule.threshold_type == AlertRuleThresholdType.ABOVE.value
        else Condition.GREATER_OR_EQUAL
    )
    if alert_rule.resolve_threshold is not None:
        resolve_threshold = alert_rule.resolve_threshold
    else:
        detector_triggers = DataCondition.objects.filter(
            condition_group=detector.workflow_condition_group
        )
        warning_data_condition = detector_triggers.filter(
            condition_result=DetectorPriorityLevel.MEDIUM
        ).first()
        if warning_data_condition is not None:
            resolve_threshold = warning_data_condition.comparison
        else:
            critical_data_condition = detector_triggers.filter(
                condition_result=DetectorPriorityLevel.HIGH
            ).first()
            if critical_data_condition is None:
                logger.info(
                    "no critical or warning data conditions exist for detector data condition group",
                    extra={"detector_data_condition_group": detector_triggers},
                )
                raise Exception(
                    "No critical or warning data conditions exist for detector data condition group"
                )
            else:
                resolve_threshold = critical_data_condition.comparison
    DataCondition.objects.create(
        comparison=resolve_threshold,
        condition_result=DetectorPriorityLevel.OK,
        type=resolve_threshold_type,
        condition_group=detector.workflow_condition_group,
    )


def migrate_metric_alerts(apps: Apps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    AlertRule = apps.get_model("sentry", "AlertRule")
    AlertRuleTrigger = apps.get_model("sentry", "AlertRuleTrigger")
    AlertRuleActivity = apps.get_model("sentry", "AlertRuleActivity")
    AlertRuleProjects = apps.get_model("sentry", "AlertRuleProjects")
    RuleSnooze = apps.get_model("sentry", "RuleSnooze")

    AlertRuleDetector = apps.get_model("workflow_engine", "AlertRuleDetector")
    AlertRuleWorkflow = apps.get_model("workflow_engine", "AlertRuleWorkflow")
    DataConditionGroup = apps.get_model("workflow_engine", "DataConditionGroup")
    DetectorWorkflow = apps.get_model("workflow_engine", "DetectorWorkflow")
    Workflow = apps.get_model("workflow_engine", "Workflow")

    # MAIN MIGRATION LOOP STARTS HERE
    alert_rules = (
        AlertRule.objects_with_snapshots.filter(
            status__in=[
                AlertRuleStatus.PENDING.value,
                AlertRuleStatus.DISABLED.value,
                AlertRuleStatus.NOT_ENOUGH_DATA.value,
            ]
        )
        .filter(~Exists(AlertRuleDetector.objects.filter(alert_rule_id=OuterRef("id"))))
        .filter(Exists(AlertRuleProjects.objects.filter(alert_rule_id=OuterRef("id"))))
    )

    for alert_rule in RangeQuerySetWrapper(alert_rules):
        organization_id = alert_rule.organization.id
        try:
            with transaction.atomic(router.db_for_write(AlertRule)):
                project = alert_rule.projects.first()
                if not project:
                    # we will not hit this, but just to be extra sure
                    logger.info(
                        "alert rule missing project, skipping",
                        extra={"alert_rule_id": alert_rule.id},
                    )
                    continue
                snoozed = None
                try:
                    snoozed = RuleSnooze.objects.get(alert_rule_id=alert_rule.id, user_id=None)
                except RuleSnooze.DoesNotExist:
                    pass
                enabled = (
                    True
                    if snoozed is None and alert_rule.status == AlertRuleStatus.PENDING.value
                    else False
                )

                create_activity = AlertRuleActivity.objects.filter(
                    alert_rule_id=alert_rule.id, type=AlertRuleActivityType.CREATED.value
                ).first()

                # create data source
                data_source = _create_data_source(apps, alert_rule)

                # create detector DCG
                data_condition_group = DataConditionGroup.objects.create(
                    organization_id=organization_id,
                )
                # create detector
                detector = _create_detector(
                    apps,
                    alert_rule,
                    project,
                    data_condition_group,
                    create_activity,
                    enabled,
                )
                # create workflow
                workflow = Workflow.objects.create(
                    name=_get_workflow_name(apps, alert_rule),
                    organization_id=organization_id,
                    when_condition_group=None,
                    enabled=True,
                    created_by_id=create_activity.user_id if create_activity else None,
                    owner_user_id=alert_rule.user_id,
                    owner_team=alert_rule.team,
                    config={},
                )
                Workflow.objects.filter(id=workflow.id).update(date_added=alert_rule.date_added)

                data_source.detectors.set([detector])

                # create detector state
                _create_detector_state(apps, alert_rule, project, detector)
                # create lookup tables
                AlertRuleDetector.objects.create(alert_rule_id=alert_rule.id, detector=detector)
                AlertRuleWorkflow.objects.create(alert_rule_id=alert_rule.id, workflow=workflow)
                DetectorWorkflow.objects.create(detector=detector, workflow=workflow)

                # migrate triggers
                triggers = AlertRuleTrigger.objects.filter(alert_rule_id=alert_rule.id)
                for trigger in triggers:
                    # migrates the trigger and its associated actions
                    _migrate_trigger(apps, trigger, detector, workflow)

                # migrate resolve threshold
                if alert_rule.detection_type != "dynamic":
                    _migrate_resolve_threshold(apps, alert_rule, detector)

                logger.info(
                    "Successfully migrated alert rule",
                    extra={"alert_rule_id": alert_rule.id},
                )
        except Exception as e:
            logger.info(
                "error when migrating alert rule",
                extra={"error": str(e), "alert_rule_id": alert_rule.id},
            )
            sentry_sdk.capture_exception(e)


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production.
    # This should only be used for operations where it's safe to run the migration after your
    # code has deployed. So this should not be used for most operations that alter the schema
    # of a table.
    # Here are some things that make sense to mark as post deployment:
    # - Large data migrations. Typically we want these to be run manually so that they can be
    #   monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   run this outside deployments so that we don't block them. Note that while adding an index
    #   is a schema change, it's completely safe to run the operation after the code has deployed.
    # Once deployed, run these manually via: https://develop.sentry.dev/database-migrations/#migration-deployment

    is_post_deployment = True

    dependencies = [
        ("workflow_engine", "0070_migrate_remaining_anomaly_detection_alerts"),
    ]

    operations = [
        migrations.RunPython(
            migrate_metric_alerts,
            migrations.RunPython.noop,
            hints={"tables": ["sentry_alertrule"]},
        )
    ]
