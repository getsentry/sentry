# Generated by Django 2.2.28 on 2023-06-22 15:55
import re
from typing import Set

from django.db import migrations

from sentry.api.issue_search import parse_search_query
from sentry.new_migrations.migrations import CheckedMigration
from sentry.utils.query import RangeQuerySetWrapperWithProgressBar


def update_saved_search_query(apps, schema_editor):
    SavedSearch = apps.get_model("sentry", "SavedSearch")
    assigned_regex = re.compile(r"assigned:\[.*]", re.IGNORECASE)
    assigned_to_regex = re.compile(r"assigned_to:\[.*]", re.IGNORECASE)
    assigned_or_suggested_regex = re.compile(r"assigned_or_suggested:\[.*]", re.IGNORECASE)

    for ss in RangeQuerySetWrapperWithProgressBar(SavedSearch.objects.all()):
        try:
            search_filters = parse_search_query(ss.query)
        except Exception:
            continue

        filters_might_require_update = [
            sf for sf in search_filters if sf.key.name in ("assigned_to", "assigned_or_suggested")
        ]

        if filters_might_require_update:
            query = ss.query
            # TODO: this logic is broken
            #       the regex will replace the first occurrence only
            #       queries with multiple `assigned` / `assigned_to` / `assigned_or_suggested` terms won't
            #       be correctly migrated
            for f in filters_might_require_update:
                if f.key.name in ("assigned_to", "assigned_or_suggested"):
                    in_syntax = isinstance(f.value.raw_value, list)
                    vals_set: Set[str] = (
                        set(f.value.raw_value) if in_syntax else {f.value.raw_value}
                    )
                    if "me" in vals_set:
                        vals_set.add("my_teams")
                        joined = ", ".join(vals_set)
                        # assigned has an alias, 'assigned_to', which is equivalent, but 'assigned' seems to be more
                        # prevalent, so we use this one consistently throughout the migration
                        replacement = (
                            f"assigned:[{joined}]"
                            if f.key.name == "assigned_to"
                            else f"{f.key.name}:[{joined}]"
                        )

                        if not in_syntax:
                            if f.key.name == "assigned_to":
                                # after parsing, the key for assigned/assigned_to is fixed to 'assigned_to'
                                # but the query string could be either
                                # so, we first try replacing 'assigned_to:me' with 'assigned:me'
                                # then replace 'assigned:me with assigned:[me, my_teams]'
                                # TODO: this is broken as well will replace
                                #       'assigned:mets' -> 'assigned:[me, my_teams]ts'
                                # TODO: use re.sub(r'assigned:me($|\s)', 'replaced', 'blah assigned:meat')
                                #       to make sure 'me' is at the end of the query or terminated by a space
                                query = query.replace("assigned_to:me", "assigned:me", 1).replace(
                                    "assigned:me", replacement, 1
                                )
                            elif f.key.name == "assigned_or_suggested":
                                query = query.replace("assigned_or_suggested:me", replacement, 1)
                        else:
                            # more complicated case using the 'in' syntax where the filter values
                            # can be a list of 'me', 'none', <emails>
                            # we use regex to match and replace if necessary
                            query = assigned_regex.sub(replacement, query, 1)
                            query = assigned_to_regex.sub(replacement, query, 1)
                            query = assigned_or_suggested_regex.sub(replacement, query, 1)

            ss.query = query
            ss.save(update_fields=["query"])


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production. For
    # the most part, this should only be used for operations where it's safe to run the migration
    # after your code has deployed. So this should not be used for most operations that alter the
    # schema of a table.
    # Here are some things that make sense to mark as dangerous:
    # - Large data migrations. Typically we want these to be run manually by ops so that they can
    #   be monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   have ops run this and not block the deploy. Note that while adding an index is a schema
    #   change, it's completely safe to run the operation after the code has deployed.
    is_dangerous = True

    dependencies = [
        ("sentry", "0501_typed_bitfield_remove_labels"),
    ]

    operations = [
        migrations.RunPython(
            update_saved_search_query,
            reverse_code=migrations.RunPython.noop,
            hints={"tables": ["sentry_savedsearch"]},
        ),
    ]
