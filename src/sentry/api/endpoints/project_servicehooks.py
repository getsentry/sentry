from __future__ import absolute_import

from rest_framework import serializers, status

from sentry.api.base import DocSection
from sentry.api.bases.project import ProjectEndpoint
from sentry.api.serializers import serialize
from sentry.api.serializers.rest_framework import ListField
from sentry.models import AuditLogEntryEvent, ObjectStatus, ServiceHook, SERVICE_HOOK_EVENTS
from sentry.utils.apidocs import scenario, attach_scenarios


@scenario('ListServiceHooks')
def list_hooks_scenario(runner):
    runner.request(
        method='GET', path='/projects/%s/%s/hooks/' % (runner.org.slug, runner.default_project.slug)
    )


@scenario('CreateServiceHook')
def create_hook_scenario(runner):
    runner.request(
        method='POST',
        path='/projects/%s/%s/hooks/' % (runner.org.slug, runner.default_project.slug),
        data={'name': 'Fabulous Key'}
    )


class ServiceHookSerializer(serializers.Serializer):
    url = serializers.URLField(required=True)
    events = ListField(
        child=serializers.CharField(max_length=255),
        required=True,
    )

    def validate_events(self, attrs, source):
        value = attrs[source]
        if value:
            for event in value:
                if event not in SERVICE_HOOK_EVENTS:
                    raise serializers.ValidationError('Invalid event name: {}'.format(event))
        return attrs


class ProjectServiceHooksEndpoint(ProjectEndpoint):
    doc_section = DocSection.PROJECTS

    @attach_scenarios([list_hooks_scenario])
    def get(self, request, project):
        """
        List a Project's Service Hooks
        ``````````````````````````````

        Return a list of service hooks bound to a project.

        :pparam string organization_slug: the slug of the organization the
                                          client keys belong to.
        :pparam string project_slug: the slug of the project the client keys
                                     belong to.
        """
        queryset = ServiceHook.objects.filter(
            project_id=project.id,
        )
        status = request.GET.get('status')
        if status == 'active':
            queryset = queryset.filter(
                status=ObjectStatus.ACTIVE,
            )
        elif status == 'disabled':
            queryset = queryset.filter(
                status=ObjectStatus.DISABLED,
            )
        elif status:
            queryset = queryset.none()

        return self.paginate(
            request=request,
            queryset=queryset,
            order_by='-id',
            on_results=lambda x: serialize(x, request.user),
        )

    @attach_scenarios([create_hook_scenario])
    def post(self, request, project):
        """
        Register a new Service Hook
        ```````````````````````````

        Create a new client key bound to a project.  The key's secret and
        public key are generated by the server.

        :pparam string organization_slug: the slug of the organization the
                                          client keys belong to.
        :pparam string project_slug: the slug of the project the client keys
                                     belong to.
        :param string url: the url for the webhook
        :param array[string] events: the events to subscribe to
        """
        if not request.user.is_authenticated():
            return self.respond(status=401)

        serializer = ServiceHookSerializer(data=request.DATA)

        if serializer.is_valid():
            result = serializer.object

            hook = ServiceHook.objects.create(
                project_id=project.id,
                url=result['url'],
                actor_id=request.user.id,
                events=result.get('events'),
                application=getattr(request.auth, 'application', None) if request.auth else None,
            )

            self.create_audit_entry(
                request=request,
                organization=project.organization,
                target_object=hook.id,
                event=AuditLogEntryEvent.SERVICEHOOK_ADD,
                data=hook.get_audit_log_data(),
            )

            return self.respond(serialize(hook, request.user), status=201)
        return self.respond(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
