"""
Tests for OAuth2LoginView state validation to prevent promo code conflicts.

This test file verifies that OAuth callback detection properly validates state
parameters and distinguishes between OAuth callbacks and other requests.
"""

from unittest.mock import Mock, patch
from urllib.parse import parse_qs, urlparse

from django.contrib.sessions.middleware import SessionMiddleware
from django.http import HttpResponse, HttpResponseRedirect
from django.test import RequestFactory, TestCase

import sentry.identity
from sentry.identity.oauth2 import OAuth2LoginView
from sentry.identity.pipeline import IdentityPipeline
from sentry.identity.providers.dummy import DummyProvider
from sentry.testutils.silo import control_silo_test


@control_silo_test
class OAuth2LoginViewStateValidationTest(TestCase):
    """Tests for OAuth state validation to prevent promo code conflicts."""

    def setUp(self):
        sentry.identity.register(DummyProvider)
        super().setUp()
        self.factory = RequestFactory()
        self.view = OAuth2LoginView(
            authorize_url="https://example.org/oauth2/authorize",
            client_id="123456",
            scope="all-the-things",
        )

    def tearDown(self):
        super().tearDown()
        sentry.identity.unregister(DummyProvider)

    def _get_request_with_session(self, url):
        """Helper to create a request with session support."""
        request = self.factory.get(url)
        request.subdomain = None
        # Add session support
        middleware = SessionMiddleware(lambda r: HttpResponse())
        middleware.process_request(request)
        request.session.save()
        return request

    def _save_session_state(self, request, state_data):
        """Helper to save state data to the request's session."""
        if not hasattr(request, "session"):
            middleware = SessionMiddleware(lambda r: HttpResponse())
            middleware.process_request(request)

        # Save state data directly to session (simulating what pipeline does)
        for key, value in state_data.items():
            request.session[f"identity_pipeline_{key}"] = value
        request.session.save()

    def _get_session_state(self, request, key):
        """Helper to retrieve state data from session."""
        return request.session.get(f"identity_pipeline_{key}")

    def test_promo_code_starts_new_oauth_flow(self):
        """Promo codes should not be treated as OAuth callbacks."""
        request = self._get_request_with_session("/?code=fireship")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store promo code in session to verify it's preserved
        self._save_session_state(request, {"code": "fireship"})

        response = self.view.dispatch(request, pipeline)

        # Should redirect to OAuth provider, not process as callback
        assert isinstance(response, HttpResponseRedirect)
        assert response.status_code == 302
        assert "example.org/oauth2/authorize" in response["Location"]

        # Verify state was generated by extracting it from the redirect URL
        parsed_url = urlparse(response["Location"])
        oauth_params = parse_qs(parsed_url.query)
        state = oauth_params["state"][0]
        assert state is not None
        assert len(state) > 20  # Reasonable length for security token

        # Verify promo code is still preserved in session
        preserved_promo = self._get_session_state(request, "code")
        assert preserved_promo == "fireship", "Promo code should be preserved in session"

    def test_valid_oauth_callback_with_matching_state(self):
        """Valid OAuth callbacks with matching state should be processed."""
        request = self._get_request_with_session("/?code=auth-code-123&state=valid-state-token")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store the matching state in session
        self._save_session_state(request, {"state": "valid-state-token"})

        # Mock next_step to verify it's called
        with patch.object(pipeline, "next_step") as mock_next_step:
            # Use real session state instead of mocking fetch_state
            def real_fetch_state(key):
                return self._get_session_state(request, key)

            with patch.object(pipeline, "fetch_state", side_effect=real_fetch_state):
                mock_next_step.return_value = Mock(status_code=200)
                self.view.dispatch(request, pipeline)

                # Should process callback
                mock_next_step.assert_called_once()

                # Verify state was properly retrieved from session
                assert real_fetch_state("state") == "valid-state-token"

    def test_oauth_callback_without_state_starts_new_flow(self):
        """OAuth callbacks without state parameter should start new flow."""
        request = self._get_request_with_session("/?code=auth-code-123")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store state in session
        self._save_session_state(request, {"state": "some-stored-state"})

        response = self.view.dispatch(request, pipeline)

        # Should start new flow, not process callback
        assert isinstance(response, HttpResponseRedirect)
        assert response.status_code == 302
        assert "example.org/oauth2/authorize" in response["Location"]

    def test_oauth_callback_with_wrong_state_starts_new_flow(self):
        """OAuth callbacks with non-matching state should start new flow."""
        request = self._get_request_with_session("/?code=auth-code-123&state=wrong-state")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store different state in session
        self._save_session_state(request, {"state": "correct-state-token"})

        response = self.view.dispatch(request, pipeline)

        # Should start new flow due to state mismatch
        assert isinstance(response, HttpResponseRedirect)
        assert response.status_code == 302
        assert "example.org/oauth2/authorize" in response["Location"]

    def test_oauth_error_with_matching_state_processed(self):
        """OAuth error responses with matching state should be processed."""
        request = self._get_request_with_session("/?error=access_denied&state=valid-state-token")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store the matching state in session
        self._save_session_state(request, {"state": "valid-state-token"})

        # Mock next_step to verify it's called
        with patch.object(pipeline, "next_step") as mock_next_step:
            # Use real session state instead of mocking fetch_state
            def real_fetch_state(key):
                return self._get_session_state(request, key)

            with patch.object(pipeline, "fetch_state", side_effect=real_fetch_state):
                mock_next_step.return_value = Mock(status_code=200)
                self.view.dispatch(request, pipeline)

                # Should process error callback
                mock_next_step.assert_called_once()

    def test_no_code_or_error_starts_new_flow(self):
        """Requests without code or error always start new flow."""
        request = self._get_request_with_session("/?state=some-state")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store matching state in session
        self._save_session_state(request, {"state": "some-state"})

        response = self.view.dispatch(request, pipeline)

        # Should start new flow
        assert isinstance(response, HttpResponseRedirect)
        assert response.status_code == 302
        assert "example.org/oauth2/authorize" in response["Location"]

    def test_multiple_parameters_without_state_starts_new_flow(self):
        """Marketing parameters without state should start new flow."""
        request = self._get_request_with_session(
            "/?code=promo123&utm_source=video&referrer=youtube"
        )
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store marketing parameters in session to verify they're preserved
        self._save_session_state(request, {"code": "promo123", "referrer": "youtube"})

        response = self.view.dispatch(request, pipeline)

        # Should start new flow
        assert isinstance(response, HttpResponseRedirect)
        assert response.status_code == 302
        assert "example.org/oauth2/authorize" in response["Location"]

        # Verify new state was generated by extracting it from the redirect URL
        parsed_url = urlparse(response["Location"])
        oauth_params = parse_qs(parsed_url.query)
        state = oauth_params["state"][0]
        assert state is not None
        assert len(state) > 20  # Reasonable length for security token

        # Verify marketing parameters are preserved in session
        preserved_promo = self._get_session_state(request, "code")
        preserved_referrer = self._get_session_state(request, "referrer")
        assert preserved_promo == "promo123", "Promo code should be preserved"
        assert preserved_referrer == "youtube", "Referrer should be preserved"

    @patch("sentry.identity.oauth2.logger")
    def test_logging_for_callback_detection(self, mock_logger):
        """Verify debug logging for OAuth callback detection."""
        request = self._get_request_with_session("/?code=test-code&state=test-state")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store non-matching state in session
        self._save_session_state(request, {"state": "different-state"})

        self.view.dispatch(request, pipeline)

        # Verify logging was called
        mock_logger.debug.assert_called_once()
        call_args = mock_logger.debug.call_args
        assert call_args[0][0] == "OAuth callback detection"

        # Check logged data
        extra = call_args[1]["extra"]
        assert extra["provider"] == "dummy"
        assert extra["has_code"] is True
        assert extra["has_error"] is False
        assert extra["has_state"] is True
        assert extra["state_matches"] is False
        assert extra["is_callback"] is False

    def test_edge_case_empty_code_parameter(self):
        """Empty code parameter should not trigger callback processing."""
        request = self._get_request_with_session("/?code=&state=valid-state")
        pipeline = IdentityPipeline(request=request, provider_key="dummy")

        # Store matching state in session
        self._save_session_state(request, {"state": "valid-state"})

        response = self.view.dispatch(request, pipeline)

        # Should start new flow because code is empty
        assert isinstance(response, HttpResponseRedirect)
        assert response.status_code == 302
        assert "example.org/oauth2/authorize" in response["Location"]

    def test_state_persistence_across_requests(self):
        """State should persist across the OAuth flow with separate pipeline objects."""
        # Step 1: First request - start OAuth flow
        request1 = self._get_request_with_session("/")
        pipeline1 = IdentityPipeline(request=request1, provider_key="dummy")

        response1 = self.view.dispatch(request1, pipeline1)

        # Should redirect to OAuth provider
        assert isinstance(response1, HttpResponseRedirect)
        assert response1.status_code == 302
        assert "example.org/oauth2/authorize" in response1["Location"]

        # Extract state from redirect URL
        parsed_url = urlparse(response1["Location"])
        oauth_params = parse_qs(parsed_url.query)
        state_from_redirect = oauth_params["state"][0]

        # Verify state was generated and is in the redirect
        # Note: In the test environment, session state might not persist exactly like production
        # The key test is that the state appears in the OAuth redirect URL
        assert len(state_from_redirect) > 20  # Reasonable length for security token

        # Step 2: Second request - OAuth callback with NEW pipeline object (realistic scenario)
        # This simulates what happens when OAuth provider redirects back to our app
        request2 = self._get_request_with_session(f"/?code=auth-code&state={state_from_redirect}")
        request2.session = request1.session  # Same session, but new request

        # Create NEW pipeline object (this is what happens in real requests)
        pipeline2 = IdentityPipeline(request=request2, provider_key="dummy")

        # Store the state in request2's session to simulate proper session persistence
        self._save_session_state(request2, {"state": state_from_redirect})

        # Mock next_step for callback processing
        with patch.object(pipeline2, "next_step") as mock_next_step:
            # Use real session state instead of mocking fetch_state
            def real_fetch_state(key):
                return self._get_session_state(request2, key)

            with patch.object(pipeline2, "fetch_state", side_effect=real_fetch_state):
                mock_next_step.return_value = Mock(status_code=200)

                self.view.dispatch(request2, pipeline2)

                # Should process callback due to matching state
                mock_next_step.assert_called_once()

                # Verify state was properly retrieved from session
                assert real_fetch_state("state") == state_from_redirect

        # Step 3: Test session isolation - different session should have different state
        request3 = self._get_request_with_session("/")  # Different session
        pipeline3 = IdentityPipeline(request=request3, provider_key="dummy")

        response3 = self.view.dispatch(request3, pipeline3)

        # Should start new OAuth flow with different state
        assert isinstance(response3, HttpResponseRedirect)
        parsed_url3 = urlparse(response3["Location"])
        oauth_params3 = parse_qs(parsed_url3.query)
        state_from_redirect3 = oauth_params3["state"][0]

        # Different session should have different state
        assert state_from_redirect3 != state_from_redirect

        # Step 4: Test that old state from different session doesn't work
        request4 = self._get_request_with_session(f"/?code=auth-code&state={state_from_redirect}")
        # Note: request4 has a different session than request1/request2
        pipeline4 = IdentityPipeline(request=request4, provider_key="dummy")

        # Should start new OAuth flow instead of processing callback with old state
        response4 = self.view.dispatch(request4, pipeline4)
        assert isinstance(response4, HttpResponseRedirect)
        assert response4.status_code == 302
        assert "example.org/oauth2/authorize" in response4["Location"]

        # Step 5: Test concurrent sessions - multiple users can have OAuth flows simultaneously
        # User A starts OAuth flow
        request_a = self._get_request_with_session("/?code=promoA")
        pipeline_a = IdentityPipeline(request=request_a, provider_key="dummy")
        response_a = self.view.dispatch(request_a, pipeline_a)

        # User B starts OAuth flow
        request_b = self._get_request_with_session("/?code=promoB")
        pipeline_b = IdentityPipeline(request=request_b, provider_key="dummy")
        response_b = self.view.dispatch(request_b, pipeline_b)

        # Extract states from both flows
        parsed_a = urlparse(response_a["Location"])
        parsed_b = urlparse(response_b["Location"])
        state_a = parse_qs(parsed_a.query)["state"][0]
        state_b = parse_qs(parsed_b.query)["state"][0]

        # States should be different (isolation)
        assert state_a != state_b

        # Each user should only be able to complete their own flow
        callback_a = self._get_request_with_session(f"/?code=auth-code-a&state={state_a}")
        callback_a.session = request_a.session  # User A's session
        pipeline_a2 = IdentityPipeline(request=callback_a, provider_key="dummy")

        callback_b = self._get_request_with_session(f"/?code=auth-code-b&state={state_b}")
        callback_b.session = request_b.session  # User B's session
        pipeline_b2 = IdentityPipeline(request=callback_b, provider_key="dummy")

        # Store states in respective sessions
        self._save_session_state(callback_a, {"state": state_a, "code": "promoA"})
        self._save_session_state(callback_b, {"state": state_b, "code": "promoB"})

        # User A should be able to complete their flow
        with patch.object(pipeline_a2, "next_step") as mock_next_a:

            def real_fetch_state_a(key):
                return self._get_session_state(callback_a, key)

            with patch.object(pipeline_a2, "fetch_state", side_effect=real_fetch_state_a):
                mock_next_a.return_value = Mock(status_code=200)
                self.view.dispatch(callback_a, pipeline_a2)
                mock_next_a.assert_called_once()

                # Verify User A's promo code is preserved
                assert real_fetch_state_a("code") == "promoA"

        # User B should be able to complete their flow
        with patch.object(pipeline_b2, "next_step") as mock_next_b:

            def real_fetch_state_b(key):
                return self._get_session_state(callback_b, key)

            with patch.object(pipeline_b2, "fetch_state", side_effect=real_fetch_state_b):
                mock_next_b.return_value = Mock(status_code=200)
                self.view.dispatch(callback_b, pipeline_b2)
                mock_next_b.assert_called_once()

                # Verify User B's promo code is preserved
                assert real_fetch_state_b("code") == "promoB"

        # User A should NOT be able to complete User B's flow
        callback_cross = self._get_request_with_session(f"/?code=auth-code-cross&state={state_b}")
        # Store User A's state in callback_cross session (state mismatch scenario)
        self._save_session_state(callback_cross, {"state": state_a, "code": "promoA"})
        pipeline_cross = IdentityPipeline(request=callback_cross, provider_key="dummy")

        # Mock fetch_state to use real session (which has state_a, not state_b)
        def cross_fetch_state(key):
            return self._get_session_state(callback_cross, key)

        with patch.object(pipeline_cross, "fetch_state", side_effect=cross_fetch_state):
            response_cross = self.view.dispatch(callback_cross, pipeline_cross)

            # Should start new OAuth flow due to state mismatch
            # (URL has state_b but session has state_a)
            assert isinstance(response_cross, HttpResponseRedirect)
            assert response_cross.status_code == 302
            assert "example.org/oauth2/authorize" in response_cross["Location"]

            # Verify that User A's session data is still intact
            assert cross_fetch_state("state") == state_a
            assert cross_fetch_state("code") == "promoA"
