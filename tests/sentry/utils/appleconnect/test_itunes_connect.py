"""Tests for iTunes integration.

These tests talk directly to Apple's iTunes and are therefore unsuitable for running in CI.
Firstly you need to create a file named ``credentials.json`` in this directory::

   {
     "username": "you-itunes-email@example.com",
     "password": "your itunes password"
   }

Your account needs to have access to the "GetSentry LLC" organisation for all tests to run.
Tests which require this are marked with ``getsentryllc`` so you can disable these tests
using `pytest -m 'not getsentryllc'`.

They also need interactive login which you need to do before running the tests::

   $ sentry execfile tests/sentry/utils/appleconnect/test_itunes_connect.py
   two-factor code: xxxxxx

To test the SMS authentication flow you need to invoke:

   $ sentry execfile tests/sentry/utils/appleconnect/test_itunes_connect.py sms
   sms code: xxxxxx

And finally, once logged in you can run the tests with ``--itunes``.

   $ pytest --itunes tests/sentry/utils/appleconnect/test_itunes_connect.py
"""

import dataclasses
import pathlib
import sys

import pytest

from sentry.utils import json
from sentry.utils.appleconnect import itunes_connect

pytestmark = pytest.mark.itunes


@pytest.fixture  # type: ignore
def here() -> pathlib.Path:
    return pathlib.Path(__file__).parent


@pytest.fixture  # type: ignore
def session_cookie(here: pathlib.Path) -> str:
    """The stored session cookie, generated by running this module interactively."""
    cookie_file = here / "session-cookie.json"
    if not cookie_file.is_file():
        pytest.skip(
            "Session cookie not initialised, "
            "see tests/sentry/utils/appleconnect/test_itunes_connect.py docstring"
        )
    data = json.loads(cookie_file.read_text())
    return data["session-cookie"]  # type: ignore


@pytest.fixture  # type: ignore
def client(session_cookie: str) -> itunes_connect.ITunesClient:
    return itunes_connect.ITunesClient.from_session_cookie(session_cookie)


def test_stored_session(client: itunes_connect.ITunesClient) -> None:
    assert client.request_session_info()


def test_set_provider(client: itunes_connect.ITunesClient) -> None:
    # Make sure we have some providers to switch to
    provider_ids = [p.publicProviderId for p in client.request_available_providers()]
    assert provider_ids

    # Try setting all the providers
    for provider_id in provider_ids:
        client.set_provider(provider_id)
        assert client.request_session_info()


@dataclasses.dataclass
class GetSentryLlcBuild:
    provider_id: itunes_connect.PublicProviderId
    app_id: str
    version: str
    build: str
    platform: str


@pytest.fixture  # type: ignore
def getsentryllc_partial() -> GetSentryLlcBuild:
    """The "Sentry Cocoa Sample iOS Swift" app from "GetSentry LLC"."""
    # Note that these builds expire on App Store Connect.  If this happens you will need to
    # create a new build and update the version and build number.
    # TODO: Include instructions for this.
    return GetSentryLlcBuild(
        provider_id=itunes_connect.PublicProviderId("69a6de81-4417-47e3-e053-5b8c7c11a4d1"),
        app_id="1549832463",  # Sentry Cocoa Sample iOS Swift,
        version="7.2.0",
        build="",
        platform="iOS",
    )


@pytest.fixture  # type: ignore
def getsentryllc_dsym(getsentryllc_partial: GetSentryLlcBuild) -> GetSentryLlcBuild:
    # Note that these builds expire on App Store Connect.  If this happens you will need to
    # create a new build and update the version and build number.
    # TODO: Include instructions for this.
    getsentryllc_partial.build = "332"
    return getsentryllc_partial


@pytest.fixture  # type: ignore
def getsentryllc_no_dsym(getsentryllc_partial: GetSentryLlcBuild) -> GetSentryLlcBuild:
    # Note that these builds expire on App Store Connect.  If this happens you will need to
    # create a new build and update the version and build number.
    # TODO: Include instructions for this.
    getsentryllc_partial.build = "333"
    return getsentryllc_partial


@pytest.mark.getsentryllc  # type: ignore
def test_get_dsym_url(
    client: itunes_connect.ITunesClient, getsentryllc_dsym: GetSentryLlcBuild
) -> None:
    client.set_provider(getsentryllc_dsym.provider_id)
    url = client.get_dsym_url(
        getsentryllc_dsym.app_id,
        getsentryllc_dsym.version,
        getsentryllc_dsym.build,
        getsentryllc_dsym.platform,
    )
    assert url


@pytest.mark.getsentryllc  # type: ignore
def test_get_dsym_url_wrong_org(
    client: itunes_connect.ITunesClient, getsentryllc_dsym: GetSentryLlcBuild
) -> None:
    other_providers = [
        p
        for p in client.request_available_providers()
        if p.publicProviderId != getsentryllc_dsym.provider_id
    ]
    try:
        other_provider = other_providers[0]
    except IndexError:
        pytest.skip("Test requires a non-GetSentryLLC provider")

    cookie = client.session_cookie()
    client2 = itunes_connect.ITunesClient.from_session_cookie(cookie)
    client2.set_provider(other_provider.publicProviderId)
    with pytest.raises(itunes_connect.ForbiddenError):
        client.get_dsym_url(
            getsentryllc_dsym.app_id,
            getsentryllc_dsym.version,
            getsentryllc_dsym.build,
            getsentryllc_dsym.platform,
        )


def test_to_from_json(client: itunes_connect.ITunesClient) -> None:
    state = client.to_json()
    new_client = itunes_connect.ITunesClient.from_json(state)
    assert new_client.request_session_info()


def test_session_cookie_from_session_cookie(client: itunes_connect.ITunesClient) -> None:
    cookie = client.session_cookie()
    new_client = itunes_connect.ITunesClient.from_session_cookie(cookie)
    assert new_client.request_session_info()


def test_bad_username_password() -> None:
    client = itunes_connect.ITunesClient()
    with pytest.raises(itunes_connect.InvalidUsernamePasswordError):
        client.start_login_sequence(username="not-a-person", password="not-a-password")


@pytest.mark.getsentryllc  # type: ignore
def test_get_dsym_url_no_dsyms(
    client: itunes_connect.ITunesClient, getsentryllc_no_dsym: GetSentryLlcBuild
) -> None:
    client.set_provider(getsentryllc_no_dsym.provider_id)
    url = client.get_dsym_url(
        getsentryllc_no_dsym.app_id,
        getsentryllc_no_dsym.version,
        getsentryllc_no_dsym.build,
        getsentryllc_no_dsym.platform,
    )
    assert url is None


if __name__ == "__main__":
    use_sms = True if sys.argv[-1] == "sms" else False

    # We want to test .to_json()/.from_json() at every step as well.
    itunes_client = itunes_connect.ITunesClient()
    state = itunes_client.to_json()
    itunes_client = itunes_connect.ITunesClient.from_json(state)

    parent_dir = pathlib.Path(__file__).parent
    with open(parent_dir / "credentials.json") as fp:
        raw = fp.read()
    credentials = json.loads(raw)

    itunes_client.start_login_sequence(credentials["username"], credentials["password"])
    state = itunes_client.to_json()
    itunes_client = itunes_connect.ITunesClient.from_json(state)
    if use_sms:
        itunes_client.request_sms_auth()
        state = itunes_client.to_json()
        itunes_client = itunes_connect.ITunesClient.from_json(state)
        code = input("sms code: ")
        itunes_client.sms_code(code)
    else:
        code = input("two-factor code: ")
        itunes_client.two_factor_code(code)
        state = itunes_client.to_json()
        itunes_client = itunes_connect.ITunesClient.from_json(state)

    cookie = {"session-cookie": itunes_client.session_cookie()}
    raw_cookie = json.dumps(cookie)
    with open(parent_dir / "session-cookie.json", "w") as fp:
        fp.write(raw_cookie)
