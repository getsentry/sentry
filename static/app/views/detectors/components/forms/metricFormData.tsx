import {useFormField} from 'sentry/components/workflowEngine/form/hooks';
import type {PriorityLevel} from 'sentry/types/group';
import type {
  DataCondition,
  DataConditionGroup,
} from 'sentry/types/workflowEngine/dataConditions';
import {
  DataConditionGroupLogicType,
  DataConditionType,
} from 'sentry/types/workflowEngine/dataConditions';
import type {Detector} from 'sentry/types/workflowEngine/detectors';

/**
 * Fields are only required
 */
interface PrioritizeLevelFormData {
  /**
   * Issue is created at this priority level
   */
  initialLevel: PriorityLevel;
  /**
   * High priority value is optional depending on the initial level
   */
  highValue?: string;
  /**
   * Medium priority value is optional depending on the initial level
   */
  mediumValue?: string;
  /**
   * Optional value at which the issue is resolved
   */
  resolutionValue?: number;
}

interface MetricDetectorConditionFormData {
  /**
   * Used when kind=change for the previous value comparison
   */
  conditionComparisonAgo?: string;
  conditionType?: 'gt' | 'lte';
  conditionValue?: string;
}

export interface MetricDetectorFormData
  extends PrioritizeLevelFormData,
    MetricDetectorConditionFormData {
  aggregate: string;
  environment: string;
  kind: 'threshold' | 'change' | 'dynamic';
  name: string;
  projectId: string;
  query: string;
  visualize: string;
}

type MetricDetectorFormFieldName = keyof MetricDetectorFormData;

/**
 * Enables type-safe form field names.
 * Helps you find areas setting specific fields.
 */
export const METRIC_DETECTOR_FORM_FIELDS = {
  // Core detector fields
  aggregate: 'aggregate',
  query: 'query',
  kind: 'kind',
  name: 'name',
  visualize: 'visualize',
  environment: 'environment',
  projectId: 'projectId',

  // Priority level fields
  initialLevel: 'initialLevel',
  highValue: 'highValue',
  mediumValue: 'mediumValue',
  resolutionValue: 'resolutionValue',

  // Condition fields
  conditionComparisonAgo: 'conditionComparisonAgo',
  conditionType: 'conditionType',
  conditionValue: 'conditionValue',
} satisfies Record<MetricDetectorFormFieldName, MetricDetectorFormFieldName>;

export function useMetricDetectorFormField<T extends MetricDetectorFormFieldName>(
  name: T
): MetricDetectorFormData[T] {
  const value = useFormField(name);
  return value;
}

/**
 * Creates a SnubaQuery data source for metric detection
 */
function createMetricDataSource(formData: MetricDetectorFormData): {
  aggregate: string;
  dataset: string;
  environment: string | null | undefined;
  eventTypes: string[];
  query: string;
  queryType: string;
  timeWindow: number;
} {
  return {
    // id: uniqueId(),
    // organizationId: '', // Will be generated by backend
    // type: 'snuba_query_subscription',
    // sourceId: uniqueId(),
    // id: uniqueId(),
    // subscription: '', // Will be generated by backend
    // id: uniqueId(),
    dataset: 'events',
    query: formData.query, // Empty strings are now allowed
    aggregate: 'count()', // TODO must be function style to work
    timeWindow: 3600, // Default 1 hour window
    environment: formData.environment || null, // Null when blank
    eventTypes: ['error'], // TODO
    queryType: 0, // ERROR type = 0 (integer value)
  };
}

/**
 * Creates data conditions for metric detection (trigger and resolution)
 */
function createMetricConditions(
  formData: MetricDetectorFormData
): Array<Omit<DataCondition, 'id'>> {
  const conditions: Array<Omit<DataCondition, 'id'>> = [];

  if (!formData.conditionType) {
    return conditions;
  }

  // Map form priority levels to DetectorPriorityLevel enum values
  const priorityLevelMap = {
    low: 25, // DetectorPriorityLevel.LOW
    medium: 50, // DetectorPriorityLevel.MEDIUM
    high: 75, // DetectorPriorityLevel.HIGH
  };

  // Handle empty conditionValue by defaulting to 0
  const comparisonValue = formData.conditionValue
    ? parseFloat(formData.conditionValue)
    : 0;

  // Skip if we couldn't parse a valid number and it wasn't empty
  if (isNaN(comparisonValue) && formData.conditionValue) {
    return conditions;
  }

  // Only create trigger condition with "gt" type (backend doesn't support "lte")
  if (formData.conditionType === 'gt') {
    conditions.push({
      // id: uniqueId(),
      type: DataConditionType.GREATER,
      comparison: comparisonValue,
      conditionResult: priorityLevelMap[formData.initialLevel] || priorityLevelMap.medium,
    });
  }

  return conditions;
}

/**
 * Creates a condition group from metric conditions
 */
function createMetricConditionGroup(
  conditions: Array<Omit<DataCondition, 'id'>>
): Omit<DataConditionGroup, 'id'> | null {
  if (conditions.length === 0) {
    return null;
  }

  return {
    // id: uniqueId(),
    logicType: DataConditionGroupLogicType.ANY,
    conditions: conditions as any,
    actions: [],
  };
}

/**
 * Creates configuration object for metric detection
 */
function createMetricConfig(formData: MetricDetectorFormData): Detector['config'] {
  return {
    detectorType: 'metric_issue',
    detection_type: 'static',
    threshold_period: 1, // TODO GET FROM FORM
    // comparison_delta: formData.conditionComparisonAgo
    //   ? parseInt(formData.conditionComparisonAgo, 10)
    //   : null,
    // TODO: What are these?
    sensitivity: formData.kind === 'dynamic' ? 'medium' : null,
    seasonality: formData.kind === 'dynamic' ? null : null,
  };
}

/**
 * Converts metric detector form data to a Detector object
 */
export function getDetectorFromMetricDetectorForm(
  formData: MetricDetectorFormData
): Detector & {detectorType: string} {
  const dataSource = createMetricDataSource(formData);
  const conditions = createMetricConditions(formData);
  const conditionGroup = createMetricConditionGroup(conditions);
  const config = createMetricConfig(formData);

  // Return the Detector object matching the example structure
  return {
    name: formData.name,
    type: 'metric',
    projectId: formData.projectId,
    // disabled: false,
    conditionGroup: conditionGroup as any,
    config,
    dataSource: dataSource as any, // Change back to singular dataSource
    workflowIds: [],
    // Readonly fields - these will be set by the backend
    id: '',
    createdBy: null,
    dateCreated: '',
    dateUpdated: '',
    lastTriggered: '',
    owner: null,
    detectorType: config.detectorType as string,
  };
}
