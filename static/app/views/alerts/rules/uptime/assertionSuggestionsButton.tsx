import {useCallback, useState} from 'react';
import styled from '@emotion/styled';

import {Alert} from '@sentry/scraps/alert';
import {Button, type ButtonProps} from '@sentry/scraps/button';
import {Flex, Stack} from '@sentry/scraps/layout';
import {Text} from '@sentry/scraps/text';

import {addErrorMessage, addSuccessMessage} from 'sentry/actionCreators/indicator';
import {closeModal, openModal, type ModalRenderProps} from 'sentry/actionCreators/modal';
import {IconSeer} from 'sentry/icons';
import {t, tct} from 'sentry/locale';
import {space} from 'sentry/styles/space';
import {uniqueId} from 'sentry/utils/guid';
import {fetchMutation, useMutation} from 'sentry/utils/queryClient';
import type RequestError from 'sentry/utils/requestError/requestError';
import useOrganization from 'sentry/utils/useOrganization';
import type {
  AndOp,
  Assertion,
  AssertionSuggestion,
  AssertionSuggestionsResponse,
  Op,
  PreviewCheckPayload,
} from 'sentry/views/alerts/rules/uptime/types';

interface AssertionSuggestionsButtonProps {
  /**
   * Current assertion value from the form
   */
  currentAssertion: Assertion | null;
  /**
   * Callback to get the current form data for the test request.
   */
  getFormData: () => {
    body: string | null;
    headers: Array<[string, string]>;
    method: string;
    timeoutMs: number;
    url: string | undefined;
  };
  /**
   * Callback when user applies a suggestion
   */
  onApplySuggestion: (updatedAssertion: Assertion) => void;
  /**
   * Button size
   */
  size?: ButtonProps['size'];
}

/**
 * Adds an `id` field to an assertion Op for the frontend
 */
function addIdToOp(op: Op): Op {
  const id = uniqueId();
  switch (op.op) {
    case 'and':
    case 'or':
      return {...op, id, children: op.children.map(addIdToOp)};
    case 'not':
      return {...op, id, operand: addIdToOp(op.operand)};
    default:
      return {...op, id};
  }
}

interface SuggestionsModalProps extends ModalRenderProps {
  currentAssertion: Assertion | null;
  onApplySuggestion: (updatedAssertion: Assertion) => void;
  suggestions: AssertionSuggestion[];
}

function SuggestionsModal({
  Header,
  Body,
  Footer,
  suggestions,
  currentAssertion,
  onApplySuggestion,
}: SuggestionsModalProps) {
  const handleApplySuggestion = useCallback(
    (suggestion: AssertionSuggestion) => {
      const newOp = addIdToOp(suggestion.assertion_json);

      const newRoot: AndOp = currentAssertion?.root
        ? {
            ...currentAssertion.root,
            children: [...currentAssertion.root.children, newOp],
          }
        : {
            op: 'and',
            id: uniqueId(),
            children: [newOp],
          };

      onApplySuggestion({root: newRoot});
      addSuccessMessage(t('Assertion added'));
    },
    [currentAssertion, onApplySuggestion]
  );

  const handleApplyAll = useCallback(() => {
    if (!suggestions || suggestions.length === 0) {
      return;
    }

    const newOps = suggestions.map(s => addIdToOp(s.assertion_json));

    const newRoot: AndOp = currentAssertion?.root
      ? {
          ...currentAssertion.root,
          children: [...currentAssertion.root.children, ...newOps],
        }
      : {
          op: 'and',
          id: uniqueId(),
          children: newOps,
        };

    onApplySuggestion({root: newRoot});
    closeModal();
    addSuccessMessage(
      tct('Added [count] assertions', {
        count: suggestions.length,
      })
    );
  }, [suggestions, currentAssertion, onApplySuggestion]);

  return (
    <div>
      <Header closeButton>
        <Flex gap="sm" align="center">
          <IconSeer />
          {t('AI Assertion Suggestions')}
        </Flex>
      </Header>
      <Body>
        <Stack gap="lg">
          <Alert.Container>
            <Alert variant="info">
              {t(
                'These suggestions are generated by AI based on the HTTP response. Review each suggestion before applying.'
              )}
            </Alert>
          </Alert.Container>

          <Stack gap="md">
            {suggestions.map((suggestion, index) => (
              <SuggestionCard
                key={index}
                suggestion={suggestion}
                onApply={() => handleApplySuggestion(suggestion)}
              />
            ))}
          </Stack>
        </Stack>
      </Body>
      <Footer>
        <Flex gap="sm" justify="end">
          <Button onClick={() => closeModal()} priority="default">
            {t('Cancel')}
          </Button>
          <Button onClick={handleApplyAll} priority="primary">
            {t('Apply All')}
          </Button>
        </Flex>
      </Footer>
    </div>
  );
}

/**
 * Button component that generates AI-powered assertion suggestions using Seer.
 * Opens a modal displaying suggestions that can be applied to the form.
 */
export function AssertionSuggestionsButton({
  getFormData,
  currentAssertion,
  onApplySuggestion,
  size,
}: AssertionSuggestionsButtonProps) {
  const organization = useOrganization();
  const [suggestions, setSuggestions] = useState<AssertionSuggestion[] | null>(null);

  const {mutate: generateSuggestions, isPending} = useMutation<
    AssertionSuggestionsResponse,
    RequestError,
    PreviewCheckPayload
  >({
    mutationFn: (payload: PreviewCheckPayload) =>
      fetchMutation<AssertionSuggestionsResponse>({
        url: `/organizations/${organization.slug}/uptime-assertion-suggestions/`,
        method: 'POST',
        data: {...payload},
      }),
    onSuccess: response => {
      if (response.suggestions && response.suggestions.length > 0) {
        setSuggestions(response.suggestions);
        openModal(modalProps => (
          <SuggestionsModal
            {...modalProps}
            suggestions={response.suggestions!}
            currentAssertion={currentAssertion}
            onApplySuggestion={onApplySuggestion}
          />
        ));
        addSuccessMessage(
          tct('Generated [count] assertion suggestions', {
            count: response.suggestions.length,
          })
        );
      } else {
        addErrorMessage(t('No suggestions could be generated for this response'));
      }
    },
    onError: () => {
      addErrorMessage(t('Failed to generate assertion suggestions'));
    },
  });

  const handleGenerateClick = useCallback(() => {
    const formData = getFormData();

    if (!formData.url) {
      addErrorMessage(t('Please enter a URL first'));
      return;
    }

    generateSuggestions({
      url: formData.url,
      timeoutMs: formData.timeoutMs,
      method: formData.method,
      headers: formData.headers,
      body: formData.body,
    });
  }, [getFormData, generateSuggestions]);

  // Allow re-opening the modal with cached suggestions
  const handleClick = useCallback(() => {
    if (suggestions && suggestions.length > 0) {
      openModal(modalProps => (
        <SuggestionsModal
          {...modalProps}
          suggestions={suggestions}
          currentAssertion={currentAssertion}
          onApplySuggestion={onApplySuggestion}
        />
      ));
    } else {
      handleGenerateClick();
    }
  }, [suggestions, currentAssertion, onApplySuggestion, handleGenerateClick]);

  return (
    <Button
      onClick={handleClick}
      busy={isPending}
      disabled={isPending}
      size={size}
      icon={<IconSeer />}
      title={t('Use AI to suggest assertions based on response')}
    >
      {t('Suggest Assertions')}
    </Button>
  );
}

interface SuggestionCardProps {
  onApply: () => void;
  suggestion: AssertionSuggestion;
}

function SuggestionCard({suggestion, onApply}: SuggestionCardProps) {
  const getAssertionLabel = () => {
    switch (suggestion.assertion_type) {
      case 'status_code':
        return tct('Status code [comparison] [value]', {
          comparison: suggestion.comparison.replace('_', ' '),
          value: suggestion.expected_value,
        });
      case 'json_path':
        return tct('JSON path [path] [comparison] [value]', {
          path: suggestion.json_path,
          comparison: suggestion.comparison.replace('_', ' '),
          value: `"${suggestion.expected_value}"`,
        });
      case 'header':
        return tct('Header [name] [comparison] [value]', {
          name: suggestion.header_name,
          comparison: suggestion.comparison.replace('_', ' '),
          value: `"${suggestion.expected_value}"`,
        });
      default:
        return t('Unknown assertion type');
    }
  };

  const confidencePercent = Math.round(suggestion.confidence * 100);

  return (
    <SuggestionCardContainer>
      <Stack gap="sm">
        <Flex justify="between" align="center">
          <Text bold>{getAssertionLabel()}</Text>
          <ConfidenceBadge confidence={suggestion.confidence}>
            {tct('[percent]% confidence', {percent: confidencePercent})}
          </ConfidenceBadge>
        </Flex>
        <Text size="sm">{suggestion.explanation}</Text>
        <Flex justify="end">
          <Button size="xs" onClick={onApply}>
            {t('Apply')}
          </Button>
        </Flex>
      </Stack>
    </SuggestionCardContainer>
  );
}

const SuggestionCardContainer = styled('div')`
  padding: ${space(2)};
  border: 1px solid ${p => p.theme.tokens.border.primary};
  border-radius: ${p => p.theme.radius.md};
  background: ${p => p.theme.tokens.background.secondary};
`;

const ConfidenceBadge = styled('span')<{confidence: number}>`
  font-size: ${p => p.theme.font.size.sm};
  padding: ${space(0.25)} ${space(0.75)};
  border-radius: ${p => p.theme.radius.sm};
  background: ${p =>
    p.confidence >= 0.8
      ? p.theme.tokens.graphics.success.vibrant
      : p.confidence >= 0.5
        ? p.theme.tokens.graphics.warning.vibrant
        : p.theme.tokens.graphics.danger.vibrant};
  color: ${p => p.theme.tokens.content.primary};
`;
